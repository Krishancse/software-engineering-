The "build and fix model," often referred to as the ad hoc model, is a software development approach that doesn't follow a formal specification or design process. 
Instead, it revolves around creating an initial version of the software and continually refining it based on user input until their requirements are met. 
This iterative cycle persists until the software becomes functional for the user. 
However, this method is cautioned against due to its absence of structured design and the potential risk of compromising software acceptance.

**Phases of the Build and Fix Model:**
1. **Build Phase:** During this stage, the software code is generated without a predefined design and is then progressed to the subsequent phase.
2. **Fix Phase:** In this phase, the code generated during the build phase is polished to eliminate errors. Furthermore, modifications are introduced to align with user needs.

**Advantages:**
- Requires less specialized experience in comparison to alternative methods, prioritizing programming skills.
- Best suited for compact software projects with limited intricacies.
- Minimized project planning is required, facilitating quicker project initiation.
- The absence of formal design expedites the initial development phase.

**Disadvantages:**
- The absence of formal design and structure leads to an impromptu and informal development process.
- Absence of mechanisms to gauge progress, quality, or risks during development.
- The constant need for revisions, incurring higher costs until user expectations are fulfilled.
- Maintenance of software becomes problematic due to the lack of proper design, impeding modifications.
- Quality control is at risk, potentially resulting in errors and inefficiencies.

In conclusion, the build and fix model is centered around a recurring process of crafting and refining software based on user feedback until it becomes functionally usable.
Although suitable for minor projects and scenarios demanding rapid development, its dearth of structured design and planning leaves it susceptible to errors and challenges in maintenance. 
As such, this approach is discouraged in favor of more organized and methodical software engineering practices.
